<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Containerization with Docker | Blog</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Containerization with Docker" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Containerization" />
<meta property="og:description" content="Containerization" />
<link rel="canonical" href="https://javiervidrua.github.io/blog/jekyll/update/2021/09/22/Containerization-with-Docker.html" />
<meta property="og:url" content="https://javiervidrua.github.io/blog/jekyll/update/2021/09/22/Containerization-with-Docker.html" />
<meta property="og:site_name" content="Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-09-22T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Containerization with Docker" />
<script type="application/ld+json">
{"headline":"Containerization with Docker","dateModified":"2021-09-22T00:00:00+02:00","datePublished":"2021-09-22T00:00:00+02:00","@type":"BlogPosting","url":"https://javiervidrua.github.io/blog/jekyll/update/2021/09/22/Containerization-with-Docker.html","mainEntityOfPage":{"@type":"WebPage","@id":"https://javiervidrua.github.io/blog/jekyll/update/2021/09/22/Containerization-with-Docker.html"},"description":"Containerization","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://javiervidrua.github.io/blog/feed.xml" title="Blog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Containerization with Docker</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-09-22T00:00:00+02:00" itemprop="datePublished">Sep 22, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="containerization">Containerization</h2>

<p>Containerization is a process that consists of packaging code and all of its dependencies, so it can be moved from one execution environment to another and executed quickly and reliably.</p>

<p>It is a type of OS virtualization, through which applications run and are isolated in what are called “containers”.</p>

<h3 id="benefits">Benefits</h3>

<p>There are many benefits to using virtualization:</p>
<ul>
  <li>Portability</li>
  <li>Scalability</li>
  <li>Faster deployment</li>
  <li>High productivity</li>
  <li>Enhanced security</li>
  <li>Continuity (if one fails, it does not affect the others)</li>
</ul>

<h3 id="differences-with-virtualization">Differences with virtualization</h3>

<p>Virtualization uses software to create an abstraction layer over the computer hardware, so they can be divided and used as if there were multiple computers (called VMs). Each VM has its own OS.</p>

<p>With virtualization, you can run multiple computers under the same real computer, but with containerization, you can run multiple services under the same OS on a single computer.</p>

<p>Furthermore, virtualization is a heavyweight operation, in comparison to containerization, which is a lightweight operation.</p>

<p>On one hand, virtualization provides complete isolation, on the other hand, containerization provides less isolation from the host OS.</p>

<p>But the most important difference is that virtualization is not portable, where as containerization was built to be portable.</p>

<h2 id="docker">Docker</h2>

<p>Docker is the most well-known containerization tool. It goes by the keywords “develop”, “ship” and “run” anywhere.</p>

<p>It provides what is called Docker Platform, that allows for container development, testing and deployment.</p>

<p>Docker uses a client-server architecture, so the client and the daemon can be in different servers.</p>

<p>The architecture components are:</p>
<ul>
  <li>Docker Host: Includes the Docker daemon (one of the most core components), which handles Docker Objects such as images, containers, networks and volumes.</li>
  <li>Docker Client: Transmits the commands to the Docker deamon, which executes it.</li>
  <li>Docker Registries: They store Docker Images that can be downloaded.</li>
  <li>Docker Objects: They are the following:
    <ul>
      <li>Image: Read-only template.</li>
      <li>Container: Created when an image is run.</li>
      <li>Volume: Store the persistent data of the cointainers.</li>
      <li>Network: How the isolated containers communicate with one another. It has several network drivers.</li>
    </ul>
  </li>
  <li>Docker Engine: The core part of the Docker system. It is an application that follows a client-server architecture. It has several components:
    <ul>
      <li>Server: The daemon.</li>
      <li>REST API: To communicate with the Docker daemon.</li>
      <li>Docker CLI: Client used to enter Docker commands.</li>
    </ul>
  </li>
</ul>

<h3 id="installation">Installation</h3>

<p>For Ubuntu systems, <a href="https://docs.docker.com/engine/install/ubuntu/">this</a> is the webpage with the installation instructions.</p>

<p>The following is a script that does everything automatically, with no configuration required:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-fsSL</span> https://get.docker.com <span class="nt">-o</span> get-docker.sh
<span class="nb">sudo </span>sh get-docker.sh
</code></pre></div></div>

<p>To get the configuration of the system, run <code class="language-plaintext highlighter-rouge">docker info</code>.</p>

<h3 id="images">Images</h3>

<p>To create a Docker Image, you can write a Dockerfile using a simple syntax that defines the steps required to set everything up.</p>

<p>Here is a list of the basic commands to use and manipulate images:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">docker image build</code>: Create an image from a Docker file.</li>
  <li><code class="language-plaintext highlighter-rouge">docker image history</code>: Display an image’s history.</li>
  <li><code class="language-plaintext highlighter-rouge">docker image inspect</code>: Display detailed information about one or more images.</li>
  <li><code class="language-plaintext highlighter-rouge">docker image ls</code>: Lists the images.</li>
  <li><code class="language-plaintext highlighter-rouge">docker image prune</code>: Removes unused images.</li>
  <li><code class="language-plaintext highlighter-rouge">docker image pull</code>: Downloads an image from a registry.</li>
  <li><code class="language-plaintext highlighter-rouge">docker image push</code>: Pushes an image to a registry.</li>
  <li><code class="language-plaintext highlighter-rouge">docker image rm</code>: Deletes one or more images.</li>
  <li><code class="language-plaintext highlighter-rouge">docker image save</code>: Saves an image to a .tar archive.</li>
</ul>

<h3 id="containers">Containers</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">docker container ls</code>: Show the running containers.</li>
  <li><code class="language-plaintext highlighter-rouge">docker container stop &lt;container_name&gt;</code>: Stop the container named &lt;container_name&gt;.</li>
</ul>

<h3 id="networks">Networks</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">docker network ls</code>: List the networks.</li>
</ul>

<h3 id="network-drivers">Network drivers</h3>

<p>Docker has several network drivers available:</p>
<ul>
  <li>Bridge: Interconnects containers running under the same daemon.</li>
  <li>Host: The container shares the hosts network, but it does not have its own IP address.</li>
  <li>Overlay: Connects two or more Docker daemon hosts to form a distributed network. It can be used with encryption enabled so the communications are secure.</li>
  <li>Macvlan: Some legacy apps demand to be connected to the physical network. This driver can be used to assign a MAC address to each container’s virtual network interface.</li>
  <li>None: Used to completely disable the network on a container.</li>
</ul>

<h3 id="docker-usage-examples">Docker usage examples</h3>

<p>Build a custom image from a Dockerfile on the current working directory:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> new_image_name <span class="nb">.</span>
</code></pre></div></div>

<p>Run a Python3 program that’s on the current working directory on a Python3 container and remove the container when the program finishes:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--rm</span> <span class="nt">-v</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>/src python:3 python/src/program.py
</code></pre></div></div>

<p>Start a Python3 container in iteractive mode (open the interpreter shell):</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>/src python:3
</code></pre></div></div>

<p>Start a Python3 container and open a Bash shell:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">-v</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>/src python:3 /bin/bash
</code></pre></div></div>

<p>Create a Dockerfile from the base image of Python3 and add numpy to it, then build the image from the Dockerfile of the current working directory (<em>.</em>):</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> Dockerfile <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
FROM python:3

RUN pip3 install numpy
</span><span class="no">EOF
</span>docker build <span class="nt">-t</span> &lt;new_image_name&gt; <span class="nb">.</span>
</code></pre></div></div>

<p>Start an Nginx container to serve files of the current working directory, forwarding the port 80 of the host to the port 80 of the container. As Nginx is a web server, it will keep running until we stop it:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--rm</span> <span class="nt">-v</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>/usr/share/nginx/html <span class="nt">-p</span> 80:80 nginx:latest
</code></pre></div></div>

<p>The same as the last one, but run the container in background mode (<em>-d</em> for <em>daemon</em>):</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--rm</span> <span class="nt">-v</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>/usr/share/nginx/html <span class="nt">-p</span> 80:80 <span class="nt">-d</span> nginx:latest
</code></pre></div></div>

<p>Open a shell on a container running in the background:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker <span class="nb">exec</span> <span class="nt">-it</span> &lt;container_name&gt; /bin/bash
</code></pre></div></div>

<p>Create a network, a Mysql container in the background (setting the environment variable MYSQL_ROOT_PASSWORD to ‘root’) and a Node.js container with an open Bash shell. <strong>Note that Docker automatically sets up DNS entries so the containers can communicate with each other using their names</strong>:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network create &lt;network_name&gt;
docker run <span class="nt">--rm</span> <span class="nt">-d</span> <span class="nt">--name</span> mysql <span class="nt">--net</span> &lt;network_name&gt; <span class="nt">-e</span> <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span><span class="s1">'root'</span> mysql:5.6
docker run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="nt">--name</span> nodejs <span class="nt">--net</span> &lt;network_name&gt; nodejs:8 /bin/bash
</code></pre></div></div>

<h2 id="docker-compose">Docker Compose</h2>

<p>The best way to describe Docker Compose is “Docker on steroids”, is a tool that allows users to define and run multi-container Docker applications.</p>

<p>It uses a .yaml file that has the configuration for your application services. Once that gets defined, you can start everything with one command.</p>

<p>It is compatible with the following environments:</p>
<ul>
  <li>Production</li>
  <li>Staging</li>
  <li>Development</li>
  <li>Testing</li>
  <li>Continuous Integration</li>
</ul>

<h3 id="steps-to-use-docker-compose">Steps to use Docker Compose</h3>

<p>These are the steps to start using Docker Compose:</p>
<ol>
  <li>Create a Dockerfile.</li>
  <li>Create docker-compose.yml</li>
  <li>Run <code class="language-plaintext highlighter-rouge">docker-compose up</code>.</li>
</ol>

<p>The following is a docker-compose.yml example file:</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5000:5000"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">.:/code</span>
      <span class="pi">-</span> <span class="s">logvolume01:/var/log</span>
    <span class="na">links</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">redis</span>
  <span class="na">redis</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">logvolume01</span><span class="pi">:</span> <span class="pi">{}</span>
</code></pre></div></div>

<h3 id="docker-compose-commands">Docker Compose commands</h3>

<p>Here is a list of the basic Docker Compose commands:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">docker-compose build</code>: Build or rebuild services.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-componse create</code>: Create containers for a service.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-compose down</code>: Stop and remove containers and networks.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-compose kill</code>: Force stop service containers.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-compose ls</code>: List running compose projects.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-compose pause</code>: Pause the services.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-compose ps</code>: List containers.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-compose restart</code>: Restart containers.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-compose rm</code>: Removed stopped service containers.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-compose start</code>: Start services.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-compose stop</code>: Stop services.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-compose up</code>: Create and start containers.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-compose up -d</code>: Create and start containers in the background.</li>
  <li><code class="language-plaintext highlighter-rouge">docker-compose up -f docker-compose.json</code>: Create and start containers defined in a JSON file.</li>
</ul>

<h3 id="examples">Examples</h3>

<h4 id="example-1">Example 1</h4>

<p>You can use a JSON file instead of a YML file, but in that case you have to specify to Docker Compose the file that you want to use.</p>

<p>Start a Redis and a Mysql container. <strong>Note that with Docker Compose, the containers that you start at the same time, they will be connected to the same network automatically</strong>.</p>

<p>docker-compose.yml file:</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">redis</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">redis</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis:3.2.12</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./redis:/data</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
  <span class="na">mysql</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">mysql</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mysql:5.6</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">MYSQL_ROOT_PASSWORD</span><span class="pi">:</span> <span class="s">root</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./mysql:/var/lib/mysql</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
</code></pre></div></div>

<p>And then run <code class="language-plaintext highlighter-rouge">docker-compose -d up</code> to start the containers in the background.</p>

<h4 id="example-2">Example 2</h4>

<p>Start an Nginx server and a Node.js application, and configure the Nginx to act as a proxy for the nodejs application.</p>

<p>lb.conf file (for Nginx):</p>
<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upstream</span> <span class="n">serv</span>{
  <span class="n">server</span> <span class="n">nodejs</span>:<span class="m">3000</span>;
}

<span class="n">server</span> {
  <span class="n">listen</span> <span class="m">8080</span>;
  <span class="n">location</span> / {
    <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">serv</span>;
  }
}
</code></pre></div></div>

<p>docker-compose.yml file:</p>
<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">nodejs</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">nodejs</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">node:latest</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./app:/opt/app</span>
    <span class="c1"># Run as soon as the container starts</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">node /opt/app/app.js</span>
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:latest</span>
    <span class="c1"># Port forwarding</span>
    <span class="na">port</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">1313:8080"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx/lb.conf:/etc/nginx/conf.d/lb.conf</span>
    <span class="c1"># Wait until the nodejs service has started, then start the nginx service</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">nodejs</span>
</code></pre></div></div>

<p>And then run <code class="language-plaintext highlighter-rouge">docker-compose -d up</code> to start the containers in the background.</p>

<h4 id="example-3">Example 3</h4>

<p>The same as the last one, but now use a Dockerfile to build a custom image for the nodejs application, and we start a bunch of nodejs applications and set a load balancer with Nginx.</p>

<p>lb.conf file (for Nginx):</p>
<div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upstream</span> <span class="n">serv</span>{
  <span class="n">server</span> <span class="n">ex3_nodejs_1</span>:<span class="m">3000</span>;
  <span class="n">server</span> <span class="n">ex3_nodejs_2</span>:<span class="m">3000</span>;
  <span class="n">server</span> <span class="n">ex3_nodejs_3</span>:<span class="m">3000</span>;
  <span class="n">server</span> <span class="n">ex3_nodejs_4</span>:<span class="m">3000</span>;
}

<span class="n">server</span> {
  <span class="n">listen</span> <span class="m">8080</span>;
  <span class="n">location</span> / {
    <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">serv</span>;
  }
}
</code></pre></div></div>

<p>Dockerfile:</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">FROM node:latest</span>
</code></pre></div></div>

<p>docker-compose.yml file:</p>
<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">nodejs</span><span class="pi">:</span>
    <span class="c1">#container_name: nodejs</span>
    <span class="c1"># Use the Dockerfile in the current working directory (.) to build the container image</span>
    <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./app:/opt/app</span>
    <span class="c1"># Run as soon as the container starts</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">node /opt/app/app.js</span>
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">container_name</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:latest</span>
    <span class="c1"># Port forwarding</span>
    <span class="na">port</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">1313:8080"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx/lb.conf:/etc/nginx/conf.d/lb.conf</span>
    <span class="c1"># Wait until the nodejs service has started, then start the nginx service</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">nodejs</span>
</code></pre></div></div>

<p>And then run <code class="language-plaintext highlighter-rouge">docker-compose -d up --scale nodejs=4</code> to start the containers in the background, and start 4 containers of the nodejs application.</p>

<h2 id="docker-swarm-mode">Docker Swarm Mode</h2>

<p>Swarm Mode is a cluster management and orchestration tool that’s embedded right in the Docker Engine. If you know what Kubernetes is, the best way to describe Swarm Mode is to think about it as a Kubernetes alternative that’s easier to use and that I would recommend for simple applications that are not too complex to manage.</p>

<p>Comparing it to Docker Compose, and its ability to define and run containers, you can define and run Swarm service stacks.</p>

<p>If you want detailed information, check the <a href="https://docs.docker.com/engine/swarm/">official page</a>.</p>

<h3 id="key-concepts">Key concepts</h3>

<h4 id="node">Node</h4>

<p>A node is an <strong>instance of a Docker Engine that takes part in the swarm</strong>. You can have one or more on a single computer, but usually they are distributed across multiple machines. There are two types:</p>
<ul>
  <li>Manager node: Dispatches the work (tasks) to the worker nodes. By default, they act as worker nodes too.</li>
  <li>Worker node: Receives and execute tasks dispatched from the manager nodes. It notifies the manager of the current state of operation periodically.</li>
</ul>

<h4 id="service">Service</h4>

<p>It is the <strong>definition of the tasks that will get executed</strong>.</p>

<p>A service specification dictates the container image to use and the commands to execute inside the running containers.</p>

<p>In the replicated services model, the swarm manager sends replica tasks to the worker nodes, and for global services, the swarm runs one task for the service on every node of the cluster.</p>

<h4 id="task">Task</h4>

<p>It is made of a container and the commands to run inside said container. It is the <strong>minimum unit of swarm</strong>. Once a task gets assigned to a node, it can only run on the assigned node.</p>

<h4 id="load-balancing">Load balancing</h4>

<p>The manager node uses <strong>ingress load balancing</strong>, so the services you want are made available to the Internet. If a port is not specified, is uses a port from the range 30000-32767.</p>

<p>Like Docker Compose, Swarm Mode automatically assigns DNS records to each service, and uses internal load balancing to distribute requests between the services based on the DNS names.</p>

<h3 id="getting-started">Getting started</h3>

<p>In order to be able to use Swarm Mode there are several prerequisites that need to be satisfied:</p>
<ul>
  <li>Three Linux hosts that can communicate over a network, with Docker installed.</li>
  <li>The IP address of the manager. You should use a fixed IP address for the manager as all nodes in the swarm need to connect to it.</li>
  <li>The ports 2377, 7946 and 4789 (and 50 if you plan to use <code class="language-plaintext highlighter-rouge">--opt encrypted</code> to use secure connections between the machines) open and allowed by default.</li>
</ul>

<h4 id="creating-a-swarm">Creating a swarm</h4>

<p>Once those requirements are met, you can create a swarm. To do so, connect to the manager node and run the following command:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker swarm init <span class="nt">--advertise-addr</span> &lt;manager_IP&gt;
</code></pre></div></div>

<p>That will output something like:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Swarm initialized: current node (xi3zvyg3wgnv04jz0z36b9kyn) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-0yjkvziblj2nuwz35cl9uc7evx3p93onhbxan66gz7wsvwi7tp-02kyqwtgpjotdbzqh0bu1nj2g 10.10.10.10:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.
</code></pre></div></div>

<p>If you clear the terminal, you can get the join command for a worker by running <code class="language-plaintext highlighter-rouge">docker swarm join-token worker</code>.</p>

<p>Now we can run the following command to check the status of the nodes:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker node <span class="nb">ls</span>
</code></pre></div></div>

<p>It will output something like (note the *, it means that Docker is connected to it):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
xi3zvyg3wgnv04jz0z36b9kyn *   ubuntu     Ready     Active         Leader           20.10.8
</code></pre></div></div>

<h4 id="adding-worker-nodes-to-the-swarm">Adding worker nodes to the swarm</h4>

<p>You can run the join command provided when the swarm was initialized on the worker nodes to join the swarm. In my case:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker swarm <span class="nb">join</span> <span class="nt">--token</span> SWMTKN-1-0yjkvziblj2nuwz35cl9uc7evx3p93onhbxan66gz7wsvwi7tp-02kyqwtgpjotdbzqh0bu1nj2g 10.10.10.10:2377
</code></pre></div></div>

<p>And it will output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This node joined a swarm as a worker.
</code></pre></div></div>

<p>Now, on the manager node, we can run <code class="language-plaintext highlighter-rouge">docker node ls</code>, and we should see the new node there:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID                            HOSTNAME       STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
xi3zvyg3wgnv04jz0z36b9kyn *   ubuntu         Ready     Active         Leader           20.10.8
yox9u6ux9aom7w5mtal5woqog     ubuntuserver   Ready     Active                          20.10.8
</code></pre></div></div>

<h4 id="deploying-a-service-to-the-swarm">Deploying a service to the swarm</h4>

<p>From the manager node, create a service:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker service create <span class="nt">--replicas</span> 1 <span class="nt">--name</span> <span class="nb">test </span>alpine ping docker.com
</code></pre></div></div>

<p>That will create a service named “test”, with 1 replica, using the image python tagged 3 that runs the command <code class="language-plaintext highlighter-rouge">ping docker.com</code>.</p>

<p>Now you can inspect the services running with the command <code class="language-plaintext highlighter-rouge">docker service ls</code>.</p>

<h4 id="inspecting-a-service">Inspecting a service</h4>

<p>Run the following command to get the output in JSON format:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker service inspect &lt;ID&gt;
</code></pre></div></div>

<p>Add <code class="language-plaintext highlighter-rouge">--pretty</code> to the above command to get a more readable output.</p>

<p>To see which nodes are running the service, run <code class="language-plaintext highlighter-rouge">docker service ps &lt;service_name | service_ID&gt;</code>. Either way, it will output something like:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID             NAME      IMAGE           NODE      DESIRED STATE   CURRENT STATE           ERROR     PORTS
7ihrx5jn31fr   test.1    alpine:latest   ubuntu    Running         Running 5 minutes ago
</code></pre></div></div>

<h4 id="scaling-the-service">Scaling the service</h4>

<p>Scaling a service is really easy with Swarm Mode, just run <code class="language-plaintext highlighter-rouge">docker service scale &lt;service_name | service_ID&gt;=&lt;number_of_replicas&gt;</code>.</p>

<p>It will output:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test scaled to 3
overall progress: 3 out of 3 tasks 
1/3: running   [==================================================&gt;] 
2/3: running   [==================================================&gt;] 
3/3: running   [==================================================&gt;] 
verify: Service converged
</code></pre></div></div>

<p>Now if we list the containers of the service with <code class="language-plaintext highlighter-rouge">docker service ps &lt;service_name | service_ID&gt;</code>, we get:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID             NAME      IMAGE           NODE           DESIRED STATE   CURRENT STATE            ERROR     PORTS
7ihrx5jn31fr   test.1    alpine:latest   ubuntu         Running         Running 11 minutes ago             
z6ctn65c04h6   test.2    alpine:latest   ubuntuserver   Running         Running 32 seconds ago             
ahmdt70a0je5   test.3    alpine:latest   ubuntuserver   Running         Running 32 seconds ago
</code></pre></div></div>

<h4 id="deleting-a-service">Deleting a service</h4>

<p>Run the command <code class="language-plaintext highlighter-rouge">docker service rm &lt;service_name | service_ID&gt;</code>.</p>

<p>It will take a few seconds (30s) for the containers to be cleaned up. You can check the state with the command <code class="language-plaintext highlighter-rouge">docker container ls</code> or with <code class="language-plaintext highlighter-rouge">docker ps</code>.</p>

<h4 id="more-detailed-info">More detailed info</h4>

<p>Check these pages:</p>
<ul>
  <li><a href="https://docs.docker.com/engine/swarm/networking/#configure-service-discovery">https://docs.docker.com/engine/swarm/networking/#configure-service-discovery</a></li>
  <li><a href="https://docs.docker.com/engine/swarm/ingress/">https://docs.docker.com/engine/swarm/ingress/</a></li>
</ul>

  </div><a class="u-url" href="/blog/jekyll/update/2021/09/22/Containerization-with-Docker.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Blog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/javiervidrua"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">javiervidrua</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
